package toolcontrollers;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import utilities.HandleFiles;

import java.io.*;
import java.math.BigInteger;
import java.net.URL;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class EncoderToolController implements Initializable
{

    @FXML private Button EncodeButton;
    @FXML private Button DecodeButton;
    @FXML private TextArea PlainTextBox;
    @FXML private TextArea EncodeTextBox;
    @FXML private Button LoadPlainTextButton;
    @FXML private Button SavePlainTextButton;
    @FXML private Button LoadEncodeTextButton;
    @FXML private Button SaveEncodeTextButton;
    @FXML private ComboBox<String> MethodComboBox;
//    @FXML private TextField DelimiterTextBox;
//    @FXML private CheckBox TextCheckBox;
//    @FXML private CheckBox HexCheckBox;
//    @FXML private CheckBox UppercaseCheckBox;

    private String encodeResult;
    private String decodeResult;
    private String encodeMethod;
    private String plainText;
    private String encodeText;


    private final HandleFiles handleFiles = new HandleFiles();

    @Override
    public void initialize(URL location, ResourceBundle resources) {

        //Encode Decode Methods
        MethodComboBox.getItems().addAll(
                "Base 64",
                "Hex",
                "HTTP",
                "HTTP (Full)",
                "Unicode",
                "HTML (Simple)",
                "MD5",
                "SHA1"
        );
        MethodComboBox.getSelectionModel().selectFirst();
        MethodComboBox.setOnAction(event -> {
            if ((MethodComboBox.getValue().equals("MD5")) || (MethodComboBox.getValue().equals("SHA1"))){
                DecodeButton.setDisable(true);
                LoadEncodeTextButton.setDisable(true);
            }else {
                DecodeButton.setDisable(false);
                LoadEncodeTextButton.setDisable(false);
            }
        });


//        //Control text typed on PlainTextBox
//        PlainTextBox.setOnKeyPressed(event -> {
//
//        });


        LoadPlainTextButton.setOnAction(event -> {
            final File file = handleFiles.openFileDialog("TXT files (*.txt)","*.txt","Open Text File");
            if (file != null) {
                PlainTextBox.setText("");
                try {
                    Scanner s = new Scanner(file);
                    while (s.hasNextLine()){
                        final String a = (s.nextLine());
                        PlainTextBox.appendText(a+"\n");
                    }
                } catch (FileNotFoundException ex) {
                    System.err.println();
                }
        }});

        LoadEncodeTextButton.setOnAction(event -> {
            final File file = handleFiles.openFileDialog("TXT files (*.txt)","*.txt","Open Text File");
            if (file != null) {
                EncodeTextBox.setText("");
                try {
                    Scanner s = new Scanner(file);
                    while (s.hasNextLine()){
                        String a = (s.nextLine());
                        EncodeTextBox.appendText(a+"\n");
                    }
                } catch (FileNotFoundException ex) {
                    System.err.println();
                }
            }});

        SaveEncodeTextButton.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                EncodeTextBox,
                MethodComboBox.getValue(),
                "Encode"));

        SavePlainTextButton.setOnAction(event -> handleFiles.saveFile(
                "Text File",
                "*.txt",
                PlainTextBox,
                MethodComboBox.getValue(),
                "PlainText"));

        EncodeButton.setOnAction(event -> {
            encodeMethod = MethodComboBox.getValue();
            plainText = PlainTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "Hex":
                    encodeResult = hexEncode(plainText.getBytes());
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    encodeResult = unicodeEncode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                case "MD5":
                    encodeResult = md5Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                case "SHA1":
                    encodeResult = sha1Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
            }
        });

        DecodeButton.setOnAction(event -> {
            encodeMethod = MethodComboBox.getValue();
            encodeText = EncodeTextBox.getText();
            switch (encodeMethod){
                case "Base 64":
                    decodeResult = base64Decode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "Hex":
                    decodeResult = hexDecode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "HTTP":
                    encodeResult = httpEncode(plainText);
                    break;
                case "HTTP (Full)":
                    encodeResult = httpFullEncode(plainText);
                    break;
                case "Unicode":
                    decodeResult = unicodeDecode(encodeText);
                    PlainTextBox.setText(decodeResult);
                    break;
                case "HTML (Simple)":
                    encodeResult = htmlEncode(plainText);
                    break;
                default:
                    encodeResult = base64Encode(plainText);
                    EncodeTextBox.setText(encodeResult);
                    break;
            }
        });
    }

    private String unicodeDecode(String encodeText) {

        StringBuilder plainResult = new StringBuilder();

        Integer srcLen = encodeText.length();
        StringBuilder hex;
        int j;

        // Cycles through encoded text. Finds all instances of %XX and converts them
        // to the plain text equivalent.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                // Trailing characters present.

                    if (encodeText.charAt(i) == '%') {
                        j = i + 2;
                        hex = new StringBuilder();
                        while ((encodeText.charAt(j) != '%') && (j < srcLen - 1)) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        if (j == srcLen - 1) {
                            hex.append(encodeText, j, j + 1);
                            j++;
                        }
                        i = j - 1;
                        plainResult.append(unescape(hex.toString()));
                    } else {
                        plainResult.append(encodeText.charAt(i));
                    }
                }
            }

        return plainResult.toString();

    }

    private String unescape(String source) {
        final String unescapeText;
        int i;
        final char ch;

        i = Integer.parseInt(source, 16);

        ch = (char) i;
        unescapeText = ch + "";
        return unescapeText;
    }

    //MD5
    private String md5Encode(String plainText) {
        final String md5;
        try {
            MessageDigest mdEnc = MessageDigest.getInstance("MD5"); //Encryption algorithm
            mdEnc.update(plainText.getBytes(), 0, plainText.length());
            md5 = new BigInteger(1, mdEnc.digest()).toString(16); // Encrypted string
        }
        catch (Exception ex) {
            return null;
        }
        return md5;
    }

    //SHA1
    private String sha1Encode(String plainText) {
        String sha1 = "";
        try
        {
            MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(plainText.getBytes("UTF-8"));
            sha1 = byteToHex(crypt.digest());
        }
        catch(NoSuchAlgorithmException | UnsupportedEncodingException e)
        {
            e.printStackTrace();
        }
        return sha1;
    }
    private static String byteToHex(final byte[] hash){
        Formatter formatter = new Formatter();
        for (byte b : hash)
        {
            formatter.format("%02x", b);
        }
        final String result = formatter.toString();
        formatter.close();
        return result;
    }

    private String htmlEncode(String plainText) {
        return plainText;
    }

    private String unicodeEncode(String plainText) {
        Integer inLength;
        String prechars = "%u";
        String uniTemp;
        StringBuilder uniResult = new StringBuilder();
        String strResult = "";

        Integer srcLen = plainText.length();

        // Cycle through each input character.
        if (srcLen > 0) {

            for (int i = 0; i < srcLen; i++) {
                inLength = Integer.toString(plainText.charAt(i), 16).length();

                if (inLength > 0) {
                    uniTemp = Integer.toHexString(plainText.charAt(i));

                    if (inLength == 1) {
                        uniResult.append(prechars).append("000").append(uniTemp); // + delimiter;
                    } else if (inLength == 2) {
                        uniResult.append(prechars).append("00").append(uniTemp); // + delimiter;
                    } else if (inLength == 3) {
                        uniResult.append(prechars).append("0").append(uniTemp); // + delimiter;
                    } else if (inLength >= 4) {
                        uniResult.append(prechars).append(uniTemp); // + delimiter;
                    } else {
                        uniResult.append(" [").append(plainText.charAt(i)).append(" Not Valid] "); // + delimiter;
                    }

                } else {
                    uniResult.append(" [").append(plainText.charAt(i)).append(" Not Valid] "); // + delimiter;
                }
            }

            strResult = uniResult.toString();

        }
        return strResult;
    }

    private String httpFullEncode(String plainText) {
        return plainText;
    }

    private String httpEncode(String plainText) {
        return plainText;
    }

    //HEX
    private String hexEncode(byte[] data) {
        final StringBuilder buf = new StringBuilder();
        for (byte aData : data) {
            int half_byte = (aData >>> 4) & 0x0F;
            int two_half = 0;
            do {
                if ((0 <= half_byte) && (half_byte <= 9)) {
                    buf.append((char) ('0' + half_byte));
                } else {
                    buf.append((char) ('a' + (half_byte - 10)));
                }
                half_byte = aData & 0x0F;
            } while (two_half++ < 1);
        }
        return buf.toString();
    }
    private String hexDecode(String encodeText) {

        StringBuilder output = new StringBuilder();

        for (int i = 0; i < encodeText.length(); i += 2) {
            final String str = encodeText.substring(i, i + 2);
            output.append((char) Integer.parseInt(str, 16));
        }
        return output.toString();
    }

    //BASE 64
    private String base64Encode(String plainText) {
        return Base64.getEncoder().encodeToString(plainText.getBytes());
    }
    private String base64Decode(String encodeText) {
        final byte[] asBytes = Base64.getDecoder().decode(encodeText);
        return new String(asBytes);
    }

}
